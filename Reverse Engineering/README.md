# Reverse Engineering

The objective of this challenge was to reverse engineer a C program binary to figure out how to exploit it. The binary had a buffer overflow vulnerability. The binary also had anti-debugging and anti-disassembly features.

To exploit the binary, static analysis was done to figure out how to disable anti-debugging feature. Using HexEdit, anti-debugging feature was overwritten with NOPs (instructions). After that, dynamic analysis was done using a debugger (GDB) to figure out what was happening within the program and how to exploit it. The exploit includes a shellcode that calls '/bin/grade' to obtain the hash for submission. Spawning a new shell is not possible as the program does not allow for forking a new shell. The program also used a random value generator function which was being stored in the buffer and then the lower 8 bits were being compared with the %eax register (%al). Hence, I wrote a script to brute-force the exploit for when the value generated matches the value provided by me. My Bash script 'cracker.sh' injects a NOP sled and then the shellcode to call '/bin/grade', followed by more NOPs, the hex value for comparison, more NOPs and then the return address which will return the flow to the NOP sled and then hit the shellcode.
